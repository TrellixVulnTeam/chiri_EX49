"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToPlugins = exports.addToOutputTargetsInTree = exports.addToOutputTargets = void 0;
const ts = require("typescript");
const ast_utils_1 = require("../../utils/ast-utils");
const devkit_1 = require("@nrwl/devkit");
const ast_utils_2 = require("@nrwl/workspace/src/utils/ast-utils");
function addCodeIntoArray(source, identifier, toInsert) {
    const nodes = ast_utils_2.findNodes(source, ts.SyntaxKind.ObjectLiteralExpression);
    let node = nodes[0];
    const matchingProperties = node.properties
        .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)
        .filter((prop) => {
        if (prop.name.kind === ts.SyntaxKind.Identifier) {
            return prop.name.getText(source) == identifier;
        }
        return false;
    });
    if (!matchingProperties) {
        return [];
    }
    if (matchingProperties.length == 0) {
        // We haven't found the field in the metadata declaration. Insert a new field.
        const expr = node;
        let position;
        let toInsert2;
        if (expr.properties.length == 0) {
            position = expr.getEnd() - 1;
            toInsert2 = `  ${identifier}: [${toInsert}]\n`;
        }
        else {
            node = expr.properties[expr.properties.length - 1];
            position = node.getEnd();
            // Get the indentation of the last element, if any.
            const text = node.getFullText(source);
            if (text.match('^\r?\r?\n')) {
                toInsert2 = `,${text.match(/^\r?\n\s+/)[0]}${identifier}: [${toInsert}]`;
            }
            else {
                toInsert2 = `, ${identifier}: [${toInsert}]`;
            }
        }
        return [
            {
                type: devkit_1.ChangeType.Insert,
                index: position,
                text: `\n${toInsert2}\n`
            }
        ];
    }
    const assignment = matchingProperties[0];
    if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {
        return [];
    }
    const lastItem = getLastEntryOfOutputtargetArray(assignment);
    let toInsert2 = `, ${toInsert}`;
    if (lastItem.getText() === ',') {
        toInsert2 = toInsert;
    }
    return [
        {
            type: devkit_1.ChangeType.Insert,
            index: lastItem.getEnd(),
            text: `\n${toInsert2}\n`
        }
    ];
}
function getLastEntryOfOutputtargetArray(node) {
    const arrayEntryList = node.getChildren()[2].getChildren()[1].getChildren();
    return arrayEntryList
        .sort((first, second) => first.getStart() - second.getStart())
        .pop();
}
function addToOutputTargets(source, toInsert) {
    const outputTargetsIdentifier = 'outputTargets';
    return addCodeIntoArray(source, outputTargetsIdentifier, toInsert);
}
exports.addToOutputTargets = addToOutputTargets;
function addToOutputTargetsInTree(host, outputTargets, stencilConfigPath) {
    const stencilConfigSource = ast_utils_1.readTsSourceFile(host, stencilConfigPath);
    const changes = devkit_1.applyChangesToString(stencilConfigSource.text, addToOutputTargets(stencilConfigSource, outputTargets.join(',')));
    host.write(stencilConfigPath, changes);
}
exports.addToOutputTargetsInTree = addToOutputTargetsInTree;
function addToPlugins(source, toInsert) {
    const pluginsIdentifier = 'plugins';
    return addCodeIntoArray(source, pluginsIdentifier, toInsert);
}
exports.addToPlugins = addToPlugins;
//# sourceMappingURL=plugins.js.map